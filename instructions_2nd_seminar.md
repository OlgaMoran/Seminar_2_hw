
## Команды для работы с ветвлением

*git branch* – **выводит список всех созданных веток**

*git branch <branch_name>* – **создает ветку с именем branch_name**

*git checkout <branch_name>* – **переход на ветку branch_name**

*git branch -d <branch_name>* – **удаление ветки branch_name**

*git merge <branch_name>* – **слияние текущей ветки с веткой branch_name**

*git log --graph* – **вывод истории коммитов с визуализацией**

# Инструкция по работе с системой контроля версий Git

![git-logo](git-logo.jpg)

# Инструкция по работе с системой контроля версий Git 

## Установка

Установить git на свою машину очень просто:

* _Linux_ — нужно просто открыть терминал и установить приложение при помощи пакетного менеджера вашего дистрибутива. Для Ubuntu команда будет выглядеть следующим образом:

    >sudo apt-get install git

* _Windows_ — рекомендуется [git for windows](https://git-scm.com/download/win), так как он содержит и клиент с графическим интерфейсом, и эмулятор bash.

## Настройка

После установки git нужно добавить немного настроек. Сначала лучше настроить самые важные: имя пользователя и адрес электронной почты. Для этого необходимо открыть терминал и запустить команды:

>git config --global user.name "Ваше имя английскими буквами"

>git config --global user.email myEmail@example.com

Теперь каждое наше действие будет отмечено именем и почтой. Таким образом, пользователи всегда будут в курсе, кто отвечает за какие изменения — это вносит порядок.

Git хранит весь пакет конфигураций в файле .gitconfig, находящемся в вашем локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг –global. Если вы этого не сделаете, они будут распространяться только на текущий репозиторий.

Для того, чтобы посмотреть все настройки системы, используйте команду:

>git config --list

Если вы не до конца настроили систему перед тем, как начать работу – не волнуйстесь. Git всегда подскажет разработчику, если тот запутался, например:

1. Команда *git --help* **выводит общую документацию по Git.**
2. Если ввести *git log --help* **Git предоставит нам документацию по какой-то определенной команде (в данном случае это - log).**
3. **Если вы вдруг сделали опечатку - система подскажет вам нужную команду.**
4. **После выполнения любой команды - отчитается о том, что вы натворили.**
5. **Также Git прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше.**

## Создание Git-репозитория

Обычно вы получаете репозиторий Git одним из двух способов:

1. можно взять **локальный каталог**, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git,

2. можно **клонировать** существующий репозиторий Git из любого места.

### Создание репозитория в существующем каталоге

Если у вас **уже есть проект** в каталоге, который не находится под версионным контролем Git, то для начала **нужно перейти в него**. Для разных операционных систем это выглядит по-разному:

* для Linux:
    >**_$ cd /home/user/my_project_**

* для macOS:

    >**_$ cd /Users/user/my_project_**

* для Windows:

    >**_$ cd C:/Users/user/my_project_**

Затем выполняется команда:

>**_$ git init_**

На этом этапе проект ещё не находится под версионным контролем. Чтобы добавить под версионный контроль существующие файлы (в отличие от пустого каталога), нужно добавить их в индекс и осуществить первый коммит изменений. Добиться этого можно запустив команду **git add**, указав индексируемые файлы, а затем выполнив **git commit**:

>**_$ git add <имя файла с расширением>_**

>**_$ git commit -m "Initial commit"_**

### Клонирование существующего репозитория

Для получения копии существующего Git-репозитория, например, проекта, в который вы хотите внести свой вклад, необходимо использовать команду **git clone**.

>**_$ git clone <url-адрес удаленного репозитория>_**

## Запись изменений в репозиторий

Каждый файл в рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (**отслеживаемые**) и нет (**неотслеживаемые**). 

**Отслеживаемые файлы** — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Если кратко, то отслеживаемые файлы — это **те файлы, о которых знает Git**.

**Неотслеживаемые файлы** — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. Например, когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, так как вы изменили их с момента последнего коммита. Вы индексируете эти изменения, затем фиксируете все проиндексированные изменения, а затем цикл повторяется.

### Определение состояния файлов

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда *git status*. Если выполнитm эту команду сразу после клонирования, можно увидеть что-то вроде этого:

>**_$ git status_**

>**_On branch master_**

>**_Nothing to commit, working tree clean_**

Это означает, что у вас чистый рабочий каталог, другими словами — в нем нет отслеживаемых измененных файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь.

### Отслеживание новых файлов

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда **git add**. Чтобы начать отслеживание файла README, вы можете выполнить следующее:

>**_$ git add README_**

### Просмотр индексированных и неиндексированных изменений

Если результат работы команды **git status** покажется недостаточно информативным — например, нужно знать, что конкретно поменялось, а не только какие файлы были изменены — в этом случае можно использовать команду **git diff**. Если **git status** отвечает на эти вопросы в самом общем виде, перечисляя имена файлов, **git diff** показывает непосредственно добавленные и удалённые строки.

### Коммит изменений

Когда рабочий файл находится в таком состоянии, как вам и хотелось, можно зафиксировать изменения. 

Важно помнить, что **всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые, для которых не выполнялась комманда _git add_ после редактирования — не войдут в этот коммит. 

Простейший способ зафиксировать изменения набрать следующее:

>**_$ git commit -m "Text of our commit"_**

### Просмотр истории коммитов

После того, как было создано несколько коммитов или же был клонирован репозиторий с уже существующей историей коммитов, пригодится возможность посмотреть что было сделано — историю коммитов. 

Одним из основных и наиболее мощных инструментов для этого является команда **git log**.

Если запустить команду **git log**, можно увидеть что-то подобное:

![git log](git-log.png)

По умолчанию **git log** перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. 

Из примера можно увидеть, что данная команда перечисляет коммиты с их SHA-1 контрольными суммами, именем и электронной почтой автора, датой создания и сообщением коммита.

## Краткий перечень упомянутых комманд

*git init* – **инициализирует пустой репозиторий**

*git status* – **выводит текущие изменений в файле**

*git add (имя файла либо ./ если нужно добавить все файлы* – **добавляет версионность файлу**

*git commit -m "Message"* – **создание и фиксация изменений**

*git log* – **выводит список изменений в хронологическом порядке**

*git diff* – **выводит разницу между предыдущим коммитом и текущими изменениями**

*git checkout (номер коммита или название ветки)* – **позволяет перемещаться между коммитами либо между ветками**

## Создание новой ветки и переход в неё

Создать новую ветку можно с помощью параметра *branch*, указав имя ветки:

>*git branch new_branch_name*

Но Git не переключится на неё автоматически. Для перехода нужно использовать параметр *checkout* и добавить имя ветки.

>*git checkout new_branch_name*

Можно просматривать полный список веток, используя параметр *branch*. Команда отобразит все ветки, отметит текущую звёздочкой (*) и выделит её цветом.

>*git branch*
